

(defmethod .- ((tt tensor) &optional t2)
    (monadic '- tt))
#|
	
;;;;;;MONADIC;;;;;;
(defun monadic (op arg)
    (mapcar #'op (lst arg)))
 
(defgeneric .! (tens)
    (:method ((tens tensor))
        (monadic 'fact tens)))
    
(defun fact (n)
  (if (< n 2)
      1
    (* n (fact(- n 1)))))
    
#|
    
(defun .sin ((t1 tensor))
    (mapcar #'sin (lst t1)))
    
(defun .cos ((t1 tensor))
    (mapcar #'cos (lst t1)))
    
(defun .not ((t1 tensor))
    (mapcar (lambda (val) (if (zerop val)
                              0
                              1))
            (lst t1)))
                         
(defun shape (tensor)
    (let ((res nil))
        (invert-first-and-second (shape-aux tensor res))))
        
(defun invert-first-and-second (list-to-invert)
    (if (< (length list-to-invert) 2)
        list-to-invert
        (append (list (second list-to-invert))
                (list (first list-to-invert))
                (if (> (length list-to-invert) 2) ;; Prevents accessing null cdr
                    (cddr list-to-invert)))))
            
(defun shape-aux (tensor res-list)
    (if (listp tensor)
        (shape-aux (car tensor) (append (list (length tensor)) res-list))
        res-list))
		
(defun interval (number)
	(let ((res nil))
        (dotimes (count number)
			(setf res (append res (list (+ 1 count)))))
		(make-tensor res)))

;;;;MONADIC & DYADIC
(defgeneric dyadic-func tensor)

(defgeneric .- (tensor1 &optional tensor2))
(defmethod .- ((tensor1 tensor) &optional tensor2)
	(if (null tensor2)
	(make-tensor(mapcar #'- (lst tensor1)))
	(let ((res nil))
	(cond 	((= (length (lst tensor1))(length (lst tensor2)))
				(dotimes (count (length (lst tensor1)))
					(setf res (append res (list (- (nth count (lst tensor1)) (nth count(lst tensor2))) )))))
			((= 1 (length (lst tensor1)))
				(dotimes (count (length (lst tensor2)))
					(setf res (append res (list (- (nth 0 (lst tensor1)) (nth count (lst tensor2))))))))
			((= 1 (length (lst tensor2)))
				(dotimes (count (length (lst tensor1)))
					(setf res (append res (list (- (nth count (lst tensor1)) (nth 0 (lst tensor2))))))))
			(t (princ "tensors not of the same size")))
	(make-tensor res))))
	
(defgeneric ./ (tensor1 &optional tensor2))
(defmethod ./ ((tensor1 tensor) &optional tensor2)
	(if (null tensor2)
	(make-tensor(mapcar #'/ (lst tensor1)))
	(let ((res nil))
	(cond 	((= (length (lst tensor1))(length (lst tensor2)))
				(dotimes (count (length (lst tensor1)))
					(setf res (append res (list (/ (nth count (lst tensor1)) (nth count(lst tensor2))) )))))
			((= 1 (length (lst tensor1)))
				(dotimes (count (length (lst tensor2)))
					(setf res (append res (list (/ (nth 0 (lst tensor1)) (nth count (lst tensor2))))))))
			((= 1 (length (lst tensor2)))
				(dotimes (count (length (lst tensor1)))
					(setf res (append res (list (/ (nth count (lst tensor1)) (nth 0 (lst tensor2))))))))
			(t (princ "tensors not of the same size")))
	(make-tensor res))))

;;;;;;DYADIC;;;;;;;
(defun .+ ((tensor1 tensor) (tensor2 tensor))
	(let ((res nil))
	(cond 	((= (length (lst tensor1))(length (lst tensor2)))
				(dotimes (count (length (lst tensor1)))
					(setf res (append res (list (+ (nth count (lst tensor1)) (nth count(lst tensor2))) )))))
			((= 1 (length (lst tensor1)))
				(dotimes (count (length (lst tensor2)))
					(setf res (append res (list (+ (nth 0 (lst tensor1)) (nth count (lst tensor2))))))))
			((= 1 (length (lst tensor2)))
				(dotimes (count (length (lst tensor1)))
					(setf res (append res (list (+ (nth 0 (lst tensor2)) (nth count (lst tensor1))))))))
			(t (princ "tensors not of the same size")))
	(make-tensor res)))

	
(defun .* ((tensor1 tensor) (tensor2 tensor))
	(let ((res nil))
	(cond 	((= (length (lst tensor1))(length (lst tensor2)))
				(dotimes (count (length (lst tensor1)))
					(setf res (append res (list (* (nth count (lst tensor1)) (nth count(lst tensor2))) )))))
			((= 1 (length (lst tensor1)))
				(dotimes (count (length (lst tensor2)))
					(setf res (append res (list (* (nth 0 (lst tensor1)) (nth count (lst tensor2))))))))
			((= 1 (length (lst tensor2)))
				(dotimes (count (length (lst tensor1)))
					(setf res (append res (list (* (nth 0 (lst tensor2)) (nth count (lst tensor1))))))))
			(t (princ "tensors not of the same size")))
	(make-tensor res)))
	
(defun .// ((tensor1 tensor) (tensor2 tensor))
	(let ((res nil))
	(cond 	((= (length (lst tensor1))(length (lst tensor2)))
				(dotimes (count (length (lst tensor1)))
					(setf res (append res (list (truncate (nth count (lst tensor1)) (nth count(lst tensor2))) )))))
			((= 1 (length (lst tensor1)))
				(dotimes (count (length (lst tensor2)))
					(setf res (append res (list (truncate (nth 0 (lst tensor1)) (nth count (lst tensor2))))))))
			((= 1 (length (lst tensor2)))
				(dotimes (count (length (lst tensor1)))
					(setf res (append res (list (truncate (nth count (lst tensor1))(nth 0 (lst tensor2))))))))
			(t (princ "tensors not of the same size")))
	(make-tensor res)))
	
(defun .% ((tensor1 tensor) (tensor2 tensor))
	(let ((res nil))
	(cond 	((= (length (lst tensor1))(length (lst tensor2)))
				(dotimes (count (length (lst tensor1)))
					(setf res (append res (list (rem (nth count (lst tensor1)) (nth count(lst tensor2))) )))))
			((= 1 (length (lst tensor1)))
				(dotimes (count (length (lst tensor2)))
					(setf res (append res (list (rem (nth 0 (lst tensor1)) (nth count (lst tensor2))))))))
			((= 1 (length (lst tensor2)))
				(dotimes (count (length (lst tensor1)))
					(setf res (append res (list (rem (nth count (lst tensor1))(nth 0 (lst tensor2))))))))
			(t (princ "tensors not of the same size")))
	(make-tensor res)))
	
(defun .< ((tensor1 tensor) (tensor2 tensor))
	(let ((res nil))
	(cond 	((= (length (lst tensor1))(length (lst tensor2)))
				(dotimes (count (length (lst tensor1)))
					(if (< (nth count (lst tensor1)) (nth count(lst tensor2)))
						(setf res (append res (list 1)))
						(setf res (append res (list 0))))))
			((= 1 (length (lst tensor1)))
				(dotimes (count (length (lst tensor2)))
					(if (< (nth 0 (lst tensor1)) (nth count (lst tensor2)))
					(setf res (append res (list 1)))
					(setf res (append res (list 0))))))
			((= 1 (length (lst tensor2)))
				(dotimes (count (length (lst tensor1)))
					(if (< (nth count (lst tensor1))(nth 0 (lst tensor2)))
					(setf res (append res (list 1)))
					(setf res (append res (list 0))))))
			(t (princ "tensors not of the same size")))
	(make-tensor res)))

(defun .> ((tensor1 tensor) (tensor2 tensor))
	(let ((res nil))
	(cond 	((= (length (lst tensor1))(length (lst tensor2)))
				(dotimes (count (length (lst tensor1)))
					(if (> (nth count (lst tensor1)) (nth count(lst tensor2)))
						(setf res (append res (list 1)))
						(setf res (append res (list 0))))))
			((= 1 (length (lst tensor1)))
				(dotimes (count (length (lst tensor2)))
					(if (> (nth 0 (lst tensor1)) (nth count (lst tensor2)))
					(setf res (append res (list 1)))
					(setf res (append res (list 0))))))
			((= 1 (length (lst tensor2)))
				(dotimes (count (length (lst tensor1)))
					(if (> (nth count (lst tensor1))(nth 0 (lst tensor2)))
					(setf res (append res (list 1)))
					(setf res (append res (list 0))))))
			(t (princ "tensors not of the same size")))
	(make-tensor res)))

(defun .<= ((tensor1 tensor) (tensor2 tensor))
	(let ((res nil))
	(cond 	((= (length (lst tensor1))(length (lst tensor2)))
				(dotimes (count (length (lst tensor1)))
					(if (<= (nth count (lst tensor1)) (nth count(lst tensor2)))
						(setf res (append res (list 1)))
						(setf res (append res (list 0))))))
			((= 1 (length (lst tensor1)))
				(dotimes (count (length (lst tensor2)))
					(if (<= (nth 0 (lst tensor1)) (nth count (lst tensor2)))
					(setf res (append res (list 1)))
					(setf res (append res (list 0))))))
			((= 1 (length (lst tensor2)))
				(dotimes (count (length (lst tensor1)))
					(if (<= (nth count (lst tensor1))(nth 0 (lst tensor2)))
					(setf res (append res (list 1)))
					(setf res (append res (list 0))))))
			(t (princ "tensors not of the same size")))
	(make-tensor res)))
	
(defun .>= ((tensor1 tensor) (tensor2 tensor))
	(let ((res nil))
	(cond 	((= (length (lst tensor1))(length (lst tensor2)))
				(dotimes (count (length (lst tensor1)))
					(if (>= (nth count (lst tensor1)) (nth count(lst tensor2)))
						(setf res (append res (list 1)))
						(setf res (append res (list 0))))))
			((= 1 (length (lst tensor1)))
				(dotimes (count (length (lst tensor2)))
					(if (>= (nth 0 (lst tensor1)) (nth count (lst tensor2)))
					(setf res (append res (list 1)))
					(setf res (append res (list 0))))))
			((= 1 (length (lst tensor2)))
				(dotimes (count (length (lst tensor1)))
					(if (>= (nth count (lst tensor1))(nth 0 (lst tensor2)))
					(setf res (append res (list 1)))
					(setf res (append res (list 0))))))
			(t (princ "tensors not of the same size")))
	(make-tensor res)))
	
(defun .= ((tensor1 tensor) (tensor2 tensor))
	(let ((res nil))
	(cond 	((= (length (lst tensor1))(length (lst tensor2)))
				(dotimes (count (length (lst tensor1)))
					(if (= (nth count (lst tensor1)) (nth count(lst tensor2)))
						(setf res (append res (list 1)))
						(setf res (append res (list 0))))))
			((= 1 (length (lst tensor1)))
				(dotimes (count (length (lst tensor2)))
					(if (= (nth 0 (lst tensor1)) (nth count (lst tensor2)))
					(setf res (append res (list 1)))
					(setf res (append res (list 0))))))
			((= 1 (length (lst tensor2)))
				(dotimes (count (length (lst tensor1)))
					(if (= (nth count (lst tensor1))(nth 0 (lst tensor2)))
					(setf res (append res (list 1)))
					(setf res (append res (list 0))))))
			(t (princ "tensors not of the same size")))
	(make-tensor res)))
	
(defun .or ((tensor1 tensor) (tensor2 tensor))
	(let ((res nil))
	(cond 	((= (length (lst tensor1))(length (lst tensor2)))
				(dotimes (count (length (lst tensor1)))
					(if (zerop(or (nth count (lst tensor1)) (nth count(lst tensor2))))
						(setf res (append res (list 0)))
						(setf res (append res (list 1))))))
			((= 1 (length (lst tensor1)))
				(dotimes (count (length (lst tensor2)))
					(if (zerop(or (nth 0 (lst tensor1)) (nth count (lst tensor2))))
					(setf res (append res (list 0)))
					(setf res (append res (list 1))))))
			((= 1 (length (lst tensor2)))
				(dotimes (count (length (lst tensor1)))
					(if (zerop(or (nth count (lst tensor1))(nth 0 (lst tensor2))))
					(setf res (append res (list 0)))
					(setf res (append res (list 1))))))
			(t (princ "tensors not of the same size")))
	(make-tensor res)))
	
(defun .and ((tensor1 tensor) (tensor2 tensor))
	(let ((res nil))
	(cond 	((= (length (lst tensor1))(length (lst tensor2)))
				(dotimes (count (length (lst tensor1)))
					(if (zerop(and (nth count (lst tensor1)) (nth count(lst tensor2))))
						(setf res (append res (list 0)))
						(setf res (append res (list 1))))))
			((= 1 (length (lst tensor1)))
				(dotimes (count (length (lst tensor2)))
					(if (zerop(and (nth 0 (lst tensor1)) (nth count (lst tensor2))))
					(setf res (append res (list 0)))
					(setf res (append res (list 1))))))
			((= 1 (length (lst tensor2)))
				(dotimes (count (length (lst tensor1)))
					(if (zerop(and (nth count (lst tensor1))(nth 0 (lst tensor2))))
					(setf res (append res (list 0)))
					(setf res (append res (list 1))))))
			(t (princ "tensors not of the same size")))
	(make-tensor res)))

#|

(shape '((((1 2 3) (4 5 1))
          ((1 2 3) (4 5 1)))
         (((1 2 3) (4 5 1))
          ((1 2 3) (4 5 1)))))

    
(defun .* (tensor)
    (mapcar #'* tensor))
  
(defun ./ (tensor)
    (mapcar #'/ tensor))
    
(defun .// (tensor)
    (mapcar #'// tensor))
    
(defun .- (tensor)
    (mapcar #'- tensor))
    
(defun .% (tensor)
    (mapcar #'% tensor))
    
(defun .< (tensor)
    (mapcar #'< tensor))

|#
